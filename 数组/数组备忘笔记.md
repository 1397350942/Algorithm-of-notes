# 一、数组数据结构 

在编程语言中，常采用实现集合的两种数据结构是数组和链表结构。这两种类型的结构采用不同的方法在计算机内存中存储和访问数据。这些方法反过来导致了操作该集合的算法中的不同的时间/空间取舍。

引用维基百科上的定义：**数组由相同类型的元素（element）的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引（index）可以计算出该元素对应的存储地址。数组表示的是可以在给定的索引位置访问或替代的项的一个序列。**这和python中的列表非常相似，实际上pyhon列表的底层数据结构就是数组。数组的长度或容量在创建的时候就固定下来了。python中的array模块包含了array类，但是它只能存储同种类型的变量。


```python
# -*- coding:utf-8  -*-
"""
author: wengwenyu@aliyun.com 
date: 2019/12/27
"""
import array

help(array)

===============================输出内容==============================
Help on built-in module array:

NAME
    array

DESCRIPTION
	# 翻译 该模块定义了一种能够有效表示的对象类型一组基本值:字符、整数、浮点数、数字。数组是序列类型，它的行为很像列表，只是其中存储的对象类型受到限制
    This module defines an object type which can efficiently represent
    an array of basic values: characters, integers, floating point
    numbers.  Arrays are sequence types and behave very much like lists,
    except that the type of objects stored in them is constrained.
CLASSES
    builtins.object
        array
    
    ArrayType = class array(builtins.object)
     |  array(typecode [, initializer]) -> array
     |  
     |  Return a new array whose items are restricted by typecode, and
     |  initialized from the optional initializer value, which must be a list,
     |  string or iterable over elements of the appropriate type.
     |  
     |  Arrays represent basic values and behave very much like lists, except
     |  the type of objects stored in them is constrained. The type is specified
     |  at object creation time by using a type code, which is a single character.
     |  The following type codes are defined:
     |  
     |      Type code   C Type             Minimum size in bytes 
     |      'b'         signed integer     1 
     |      'B'         unsigned integer   1 
     |      'u'         Unicode character  2 (see note) 
     |      'h'         signed integer     2 
     |      'H'         unsigned integer   2 
     |      'i'         signed integer     2 
     |      'I'         unsigned integer   2 
     |      'l'         signed integer     4 
     |      'L'         unsigned integer   4 
     |      'q'         signed integer     8 (see note) 
     |      'Q'         unsigned integer   8 (see note) 
     |      'f'         floating point     4 
     |      'd'         floating point     8 
...省略...
```

说明: 

```python
对数组实例化的代码如下: 
    a = array.array(typecode [, initializer]) 
    typecode: 编码类型（见下表）
    initializer: 为列表、字符串或者其他可迭代的对象 
编码类型对应关系
	 |      Type code   C Type             Minimum size in bytes 
     |      'b'         signed integer     1 
     |      'B'         unsigned integer   1 
     |      'u'         Unicode character  2 (see note) 
     |      'h'         signed integer     2 
     |      'H'         unsigned integer   2 
     |      'i'         signed integer     2 
     |      'I'         unsigned integer   2 
     |      'l'         signed integer     4 
     |      'L'         unsigned integer   4 
     |      'q'         signed integer     8 (see note) 
     |      'Q'         unsigned integer   8 (see note) 
     |      'f'         floating point     4 
     |      'd'         floating point     8 
```

使用python内置的array模块简单的创建一个数组实例对象 

```python
import array

# 定义一个数组,存储有符号整数,其中存储的内容为列表中的元素
a = array.array("i", [-1, 2, 3, 4])
print(a)
a.append(0)  # 将整数0添加到列表中
print(a)
print(a.index(2)) # 查看首次出现元素2所在的索引

================输出内容===================
array('i', [-1, 2, 3, 4])
array('i', [-1, 2, 3, 4, 0])
1
```

python的第三方库numpy中的array的功能也非常强大（参阅:）

下面是自定义一个Array类,来实现一些简单的功能 

```python
class Array(object):
    def __init__(self, capacity, fillValue=None):
        """
        capacity:表示数组的容量(大小)
        fillValue:表示要往数组中填充的内容
        """
        self._items = list()
        for count in range(capacity):
            self._items.append(fillValue)

    def __len__(self):
        # 获取数组长度
        return len(self._items)

    def __str__(self):
        # 将数组中元素转为字符串
        return str(self._items)

    def __iter__(self):
        # 遍历数组
        return iter(self._items)

    def __getitem__(self, index):
        # 通过索引获取数组中的值
        return self._items[index]

    def __setitem__(self, index, newItem):
        # 替换指定位置处的值
        self._items[index] = newItem
        return self._items


if __name__ == '__main__':
    a = Array(6)
    print(a.__len__())  # 6
    for i in range(len(a)):
        a[i] = i + 1
    print(a)  # [1,2,3,4,5,6]
    print(a.__getitem__(3))  # 4
    print(a.__setitem__(3, 100))  # [1,2,3,100,5,6]
```

## 1.1、随机访问和连续内存 

计算机通过为数组项分配一段连续的内存单元，从而支持对数组的随机访问。数组在内存中是按顺序存放的，可以通过下标直接定位到某一个元素存放的位置。所以不管数组多大，它访问第一个元素所需的时间和访问最后一个元素需要的时间是一样的。

![数组_一段连续的内存](C:\Users\wengw\Documents\Algorithm-of-notes\数组\accessory\数组_一段连续的内存.png)

上面是数组array = [10,20,30,40,50,60,70]的内存图。假设第一个元素的地址值为2000，由于数组中存储的是int整数，一个整数占4个字节，那么第二个元素的地址值为2004，第三个为2008，第四个为2012。如果第i个位置处的地址值可以通过2000 + i  * 4获取。**其中第一个元素的地址值为数组的基本地址。**

## 1.2、静态内存和动态内存 

有些语言中，数组是静态数据结构。数组的长度和大小都是在编译时确定的。但是在显示情况中，数组的长度是变化的，我们并无法事先确定数组的大小。为了保险起见我们可以定义一个长度尽量长的数组，但是如果我们只存储一个元素，那么这显然是对空间的浪费；为了节省空间我们定义一个长度较短的数组，同样的，我们要存储的元素数大于数组长度时，这个数组就"放不下”需要存储的数据。在Java和C++中支持动态数组，动态数组同样占据了连续的内存块并支持随机访问。在运行时不需要指定动态数组的长度，只需要在实例化的时候指定动态数组的长度即可。python中同样支持动态数组。

## 1.3、物理大小和逻辑大小 

物理大小：数组单元的总数，或者说创建数组的时候，用来指定其容量的数字。

逻辑大小：当前可供应用程序使用的项的数目，也就是被占用的单元数

# 二、数组的操作 

## 2.1、增加数组的大小 

当要插入新的项时，并且此时数组满了，也就说物理大小和逻辑大小相等，这时候就需要增加数组的大小了。调整大小的过程包括3个步骤：

1. 创建一个新的，更大的数组
2. 将数组从旧的数组复制到新的数组中
3. 将旧的数组变量重新设置为新的数组对象

```python
# -*- coding:utf-8  -*-
"""
author: wengwenyu@aliyun.com 
date: 2019/12/27
"""
class Array(object):
    def __init__(self, capacity, fillValue=None):
        """
        capacity:表示数组的容量(大小)
        fillValue:表示要往数组中填充的内容
        """
        self._items = list()
        for count in range(capacity):
            self._items.append(fillValue)

    def __len__(self):
        # 获取数组长度
        return len(self._items)

    def __str__(self):
        # 将数组中元素转为字符串
        return str(self._items)

    def __iter__(self):
        # 遍历数组
        return iter(self._items)

    def __getitem__(self, index):
        # 通过索引获取数组中的值
        return self._items[index]

    def __setitem__(self, index, newItem):
        # 替换指定位置处的值
        self._items[index] = newItem
        return self._items


if __name__ == '__main__':
    DEFALUT_CAPACITY = 5
    logicalSize = 0
    a = Array(DEFALUT_CAPACITY)
    if logicalSize == len(a):
        temp = Array(len(a) + 1)  # 创建临时数组,长度为原数组+1
        for i in range(logicalSize):  # 将旧数组中的元素拷贝到临时数组中
            temp[i] = a[i]
        a = temp  # 将临时数组赋值给a

```

给数组添加n项的时间复杂度为O(n<sup>2</sup>)。当创建临时数组的时候，我们double数组的大小，即为：

```python
temp = Array(len(a) * 2)
```

这样时间复杂度降低了，但是牺牲的是内存空间。 

## 2.2、减小数组的大小 

当数组的逻辑大小缩小时，就会浪费内存空间。将数组中逻辑大小与物理大小之比定义为装载因子(load factor)，当装载因子小于0.25时，我们可以采取减小数组的操作，这是跟增加数组是相反的操作，其步骤如下：

1.  创建一个新的，更小的数组

2.  将数组从旧的数组复制到新的数组中

3.  将旧的数组变量重新设置为新的数组对象

```python
 	DEFALUT_CAPACITY = 5
    logicalSize = 0
    a = Array(DEFALUT_CAPACITY)
    if logicalSize <= len(a) // 4 and len(a) >= DEFALUT_CAPACITY * 2:
        """当装载因子小于0.25且数组长度大于等于默认容量的2倍时"""
        temp = Array(len(a) // 2)  # 创建临时数组,大小为原数组长度的1/2
        for i in range(logicalSize):
            temp[i] = a[i]
        a = temp
```

## 2.3、向数组中插入元素 

向数组中插入元素步骤如下：

1. 因为插入元素会改变数组的逻辑大小，先看看数组的物理大小够不够，若不够那么增加数组大小

2. 从数组的逻辑末尾开始，直到目标索引位置，将每一项向后移动一位。

3. 将新的元素赋值给目标索引位置

4. 将逻辑大小增加1

